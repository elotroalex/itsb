{"version":3,"sources":["libs/gzip.js"],"names":["crc32","require","deflate","ID1","ID2","compressionMethods","possibleFlags","FTEXT","FHCRC","FEXTRA","FNAME","FCOMMENT","osMap","fat","amiga","vmz","unix","vm/cms","atari","hpfs","macintosh","z-system","cplm","tops-20","ntfs","qdos","acorn","vfat","vms","beos","tandem","theos","os","DEFAULT_LEVEL","putByte","n","arr","push","putShort","putLong","readByte","shift","readShort","readLong","n1","n2","Math","pow","readString","charArr","String","fromCharCode","join","module","exports","zip","data","options","level","flags","out","Array","prototype","map","call","char","charCodeAt","name","timestamp","parseInt","Date","now","s","i","len","length","putString","substring","lastIndexOf","forEach","byte","unzip","t","compressionMethod","res","slice","Object","keys","some","key","ret","readBytes","inflate","splice"],"mappings":"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","file":"../../libs/gzip.min.js","sourcesContent":["(function () {\n\t'use strict';\n\n\tvar crc32 = require('crc32'),\n\t\tdeflate = require('deflate-js'),\n\t\t// magic numbers marking this file as GZIP\n\t\tID1 = 0x1F,\n\t\tID2 = 0x8B,\n\t\tcompressionMethods = {\n\t\t\t'deflate': 8\n\t\t},\n\t\tpossibleFlags = {\n\t\t\t'FTEXT': 0x01,\n\t\t\t'FHCRC': 0x02,\n\t\t\t'FEXTRA': 0x04,\n\t\t\t'FNAME': 0x08,\n\t\t\t'FCOMMENT': 0x10\n\t\t},\n\t\tosMap = {\n\t\t\t'fat': 0, // FAT file system (DOS, OS/2, NT) + PKZIPW 2.50 VFAT, NTFS\n\t\t\t'amiga': 1, // Amiga\n\t\t\t'vmz': 2, // VMS (VAX or Alpha AXP)\n\t\t\t'unix': 3, // Unix\n\t\t\t'vm/cms': 4, // VM/CMS\n\t\t\t'atari': 5, // Atari\n\t\t\t'hpfs': 6, // HPFS file system (OS/2, NT 3.x)\n\t\t\t'macintosh': 7, // Macintosh\n\t\t\t'z-system': 8, // Z-System\n\t\t\t'cplm': 9, // CP/M\n\t\t\t'tops-20': 10, // TOPS-20\n\t\t\t'ntfs': 11, // NTFS file system (NT)\n\t\t\t'qdos': 12, // SMS/QDOS\n\t\t\t'acorn': 13, // Acorn RISC OS\n\t\t\t'vfat': 14, // VFAT file system (Win95, NT)\n\t\t\t'vms': 15, // MVS (code also taken for PRIMOS)\n\t\t\t'beos': 16, // BeOS (BeBox or PowerMac)\n\t\t\t'tandem': 17, // Tandem/NSK\n\t\t\t'theos': 18 // THEOS\n\t\t},\n\t\tos = 'unix',\n\t\tDEFAULT_LEVEL = 6;\n\n\tfunction putByte(n, arr) {\n\t\tarr.push(n & 0xFF);\n\t}\n\n\t// LSB first\n\tfunction putShort(n, arr) {\n\t\tarr.push(n & 0xFF);\n\t\tarr.push(n >>> 8);\n\t}\n\n\t// LSB first\n\tfunction putLong(n, arr) {\n\t\tputShort(n & 0xffff, arr);\n\t\tputShort(n >>> 16, arr);\n\t}\n\n\tfunction putString(s, arr) {\n\t\tvar i, len = s.length;\n\t\tfor (i = 0; i < len; i += 1) {\n\t\t\tputByte(s.charCodeAt(i), arr);\n\t\t}\n\t}\n\n\tfunction readByte(arr) {\n\t\treturn arr.shift();\n\t}\n\n\tfunction readShort(arr) {\n\t\treturn arr.shift() | (arr.shift() << 8);\n\t}\n\n\tfunction readLong(arr) {\n\t\tvar n1 = readShort(arr),\n\t\t\tn2 = readShort(arr);\n\n\t\t// JavaScript can't handle bits in the position 32\n\t\t// we'll emulate this by removing the left-most bit (if it exists)\n\t\t// and add it back in via multiplication, which does work\n\t\tif (n2 > 32768) {\n\t\t\tn2 -= 32768;\n\n\t\t\treturn ((n2 << 16) | n1) + 32768 * Math.pow(2, 16);\n\t\t}\n\n\t\treturn (n2 << 16) | n1;\n\t}\n\n\tfunction readString(arr) {\n\t\tvar charArr = [];\n\n\t\t// turn all bytes into chars until the terminating null\n\t\twhile (arr[0] !== 0) {\n\t\t\tcharArr.push(String.fromCharCode(arr.shift()));\n\t\t}\n\n\t\t// throw away terminating null\n\t\tarr.shift();\n\n\t\t// join all characters into a cohesive string\n\t\treturn charArr.join('');\n\t}\n\n\t/*\n\t * Reads n number of bytes and return as an array.\n\t *\n\t * @param arr- Array of bytes to read from\n\t * @param n- Number of bytes to read\n\t */\n\tfunction readBytes(arr, n) {\n\t\tvar i, ret = [];\n\t\tfor (i = 0; i < n; i += 1) {\n\t\t\tret.push(arr.shift());\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\t/*\n\t * ZIPs a file in GZIP format. The format is as given by the spec, found at:\n\t * http://www.gzip.org/zlib/rfc-gzip.html\n\t *\n\t * Omitted parts in this implementation:\n\t */\n\tfunction zip(data, options) {\n\t\tvar flags = 0,\n\t\t\tlevel,\n\t\t\tcrc, out = [];\n\n\t\tif (!options) {\n\t\t\toptions = {};\n\t\t}\n\t\tlevel = options.level || DEFAULT_LEVEL;\n\n\t\tif (typeof data === 'string') {\n\t\t\tdata = Array.prototype.map.call(data, function (char) {\n\t\t\t\treturn char.charCodeAt(0);\n\t\t\t});\n\t\t}\n\n\t\t// magic number marking this file as GZIP\n\t\tputByte(ID1, out);\n\t\tputByte(ID2, out);\n\n\t\tputByte(compressionMethods['deflate'], out);\n\n\t\tif (options.name) {\n\t\t\tflags |= possibleFlags['FNAME'];\n\t\t}\n\n\t\tputByte(flags, out);\n\t\tputLong(options.timestamp || parseInt(Date.now() / 1000, 10), out);\n\n\t\t// put deflate args (extra flags)\n\t\tif (level === 1) {\n\t\t\t// fastest algorithm\n\t\t\tputByte(4, out);\n\t\t} else if (level === 9) {\n\t\t\t// maximum compression (fastest algorithm)\n\t\t\tputByte(2, out);\n\t\t} else {\n\t\t\tputByte(0, out);\n\t\t}\n\n\t\t// OS identifier\n\t\tputByte(osMap[os], out);\n\n\t\tif (options.name) {\n\t\t\t// ignore the directory part\n\t\t\tputString(options.name.substring(options.name.lastIndexOf('/') + 1), out);\n\n\t\t\t// terminating null\n\t\t\tputByte(0, out);\n\t\t}\n\n\t\tdeflate.deflate(data, level).forEach(function (byte) {\n\t\t\tputByte(byte, out);\n\t\t});\n\n\t\tputLong(parseInt(crc32(data), 16), out);\n\t\tputLong(data.length, out);\n\n\t\treturn out;\n\t}\n\n\tfunction unzip(data) {\n\t\t// start with a copy of the array\n\t\tvar arr = Array.prototype.slice.call(data, 0),\n\t\t\tt,\n\t\t\tcompressionMethod,\n\t\t\tflags,\n\t\t\tmtime,\n\t\t\txFlags,\n\t\t\tkey,\n\t\t\tos,\n\t\t\tcrc,\n\t\t\tsize,\n\t\t\tres;\n\n\t\t// check the first two bytes for the magic numbers\n\t\tif (readByte(arr) !== ID1 || readByte(arr) !== ID2) {\n\t\t\tthrow 'Not a GZIP file';\n\t\t}\n\n\t\tt = readByte(arr);\n\t\tt = Object.keys(compressionMethods).some(function (key) {\n\t\t\tcompressionMethod = key;\n\t\t\treturn compressionMethods[key] === t;\n\t\t});\n\n\t\tif (!t) {\n\t\t\tthrow 'Unsupported compression method';\n\t\t}\n\n\t\tflags = readByte(arr);\n\t\tmtime = readLong(arr);\n\t\txFlags = readByte(arr);\n\t\tt = readByte(arr);\n\t\tObject.keys(osMap).some(function (key) {\n\t\t\tif (osMap[key] === t) {\n\t\t\t\tos = key;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\n\t\t// just throw away the bytes for now\n\t\tif (flags & possibleFlags['FEXTRA']) {\n\t\t\tt = readShort(arr);\n\t\t\treadBytes(arr, t);\n\t\t}\n\n\t\t// just throw away for now\n\t\tif (flags & possibleFlags['FNAME']) {\n\t\t\treadString(arr);\n\t\t}\n\n\t\t// just throw away for now\n\t\tif (flags & possibleFlags['FCOMMENT']) {\n\t\t\treadString(arr);\n\t\t}\n\n\t\t// just throw away for now\n\t\tif (flags & possibleFlags['FHCRC']) {\n\t\t\treadShort(arr);\n\t\t}\n\n\t\tif (compressionMethod === 'deflate') {\n\t\t\t// give deflate everything but the last 8 bytes\n\t\t\t// the last 8 bytes are for the CRC32 checksum and filesize\n\t\t\tres = deflate.inflate(arr.splice(0, arr.length - 8));\n\t\t}\n\n\t\tif (flags & possibleFlags['FTEXT']) {\n\t\t\tres = Array.prototype.map.call(res, function (byte) {\n\t\t\t\treturn String.fromCharCode(byte);\n\t\t\t}).join('');\n\t\t}\n\n\t\tcrc = readLong(arr) >>> 0;\n\t\tif (crc !== parseInt(crc32(res), 16)) {\n\t\t\tthrow 'Checksum does not match';\n\t\t}\n\n\t\tsize = readLong(arr);\n\t\tif (size !== res.length) {\n\t\t\tthrow 'Size of decompressed file not correct';\n\t\t}\n\n\t\treturn res;\n\t}\n\n\tmodule.exports = {\n\t\tzip: zip,\n\t\tunzip: unzip,\n\t\tget DEFAULT_LEVEL() {\n\t\t\treturn DEFAULT_LEVEL;\n\t\t}\n\t};\n}());\n"]}